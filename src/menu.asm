bits 16     ; Usual 16 bit mode
org 0x7C00  ; Usual ram-mem offset

;; init
mov ax, 0x0501  ; Переходим на 1 страницу консоли
int 0x10        ; Вызываем переход с ключём 5h

;; body
xor cx, cx  ; На всякий случай

main_loop:              ; Основная логика программы:
	call draw_screen    ; * Нарисовать
	call key_listener   ; * Подождать тыка на кнопку
	call move_select    ; * Что-нибудь сделать (отреагировать на нажатие)
	
	jmp main_loop       ; Вечно повторить
	
;;;;;;;;;;;;;

key_listener:    ; Главный по кнопочкам
	xor ax, ax  ; Очищаем буфер
	int 0x16     ; Принимаем сигнал от Клавы
	
	ret          ; Говорим, что кнопку тыкнули
	
move_select:              ; Реагируем на нажатие
	cmp ax, 0x4800 ; up     Проверяем, что это стрелка вверх
	je move_select_up     ; Двигаем уголок вверх

	cmp ax, 0x5000 ; down   Проверяем, что это стрелка вниз
	je move_select_down   ; Двигаем уголок вниз
	
	ret  ; Непредвиденные обстоятельства (другая кнопка)
	      ; Просто игнорим это событие

move_select_up:      ; Аккуратно двигаем уголок вверх
	cmp cx, 0       ; Проверяем не на верху ли он
	jle just_return  ; Уголок наверху, можно забить
	
	dec cx          ; Уменьшаем индекс
	ret             ; Завершаем обработку
	
move_select_down:    ; Аккуратно двигаем уголок вниз
	cmp cx, 3       ; Проверяем не внизу ли он
	jae just_return  ; Уголок внизу, можно забить
	
	inc cx          ; Увеличиваем индекс
	ret             ; Завершаем обработку
	 
just_return:        ; Завершаем обработку
	ret             ; Завершаем обработку

draw_partition:       ; Рисуем модельку раздела
	mov bh, 0x01      ; Указываем страницу
	mov ah, 0x02      ; Говорим, что будем двигать каретку
	int 0x10          ; Двигаем каретку

	mov edx, part_template  ; Загружаем строчку
	call print_string       ; Печатаем строчку
	
	ret                     ; Завершаем печать
	
draw_screen:               ; Рисуем полностью экран
	push cx               ; Сохраняем позицию уголка

	; Чистим экран
	mov ax, 0x0600   ; 06 - прокрутка, 00 - прокрутка за счёт чистки
	mov bh, 0x07     ; 07 - приятный серый цвет
	mov cx, 0x0000   ; От точки (00h, 00h) до точки (10h, 10h)
	mov dx, 0x1010
	int 0x10         ; Чистим
	
	xor cx, cx  ; Готовим для рисования моделек
	
	.draw_loop:
		cmp cx, 4        ; Проверяем, что мы нарисовали меньше 4 моделек
		jae .draw_finish  ; Ну иначе продолжаем делать дела
		
		mov dx, 0x0004   ; Фиксируем отступ каретки 0 по вертикали и 4 по горизонтали
		mov al, cl       ; Получаем индекс строки
		mov bl, 2        ; Умножаем его на 2
		mul bl
		
		add al, 1        ; Смещаем на 1 строку (чтобы сверху было пусто и красиво)
		add dh, al       ; Меняем вертикальный отступ на посчитанный
		
		call draw_partition ; Рисуем модель раздела
		
		mov al, 0x31      ; Это 1
		add al, cl        ; Получаем истинный номер
		call print_char   ; Дописываем номер раздела
		
		inc cx            ; Переходим к следующему
		jmp .draw_loop
	
	.draw_finish:       ; Завершаем рисовашки
		pop cx          ; Считываем позицию каретки
	
		mov dx, 0x0001  ; Фиксируем отступ каретки 0 по вертикали и 1 по горизонтали
		mov al, cl      ; Получаем индекс строки
		mov bl, 2       ; Умножаем его на 2
		mul bl
		
		add al, 1       ; Смещаем на 1 строку
		add dh, al      ; Меняем вертикальный отступ на посчитанный
		
		mov bh, 0x01    ; Указываем страницу
		mov ah, 0x02    ; Говорим, что будем двигать каретку
		int 0x10        ; Двигаем каретки
		
		mov al, ">"     ; Печатаем уголок
		call print_char
		
		ret	  ; Завершаем рисовашки

print_char:
	mov ah, 0x0E
	int 0x10
	ret

print_string:
	mov al, [edx]
	inc edx
	
	or al, al
	jz print_stop
	call print_char
	jmp print_string
	
	ret
	
print_stop:
	ret
	
part_template db "Partition ", 0 ; Для модели раздела

times 510 - ($ - $$) db 0
dw 0xAA55